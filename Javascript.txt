1.数据类型
	-总共分为六种，五种基本数据类型，和一种引用数据类型
	-其中基本数据类型有
		-String(字符串)
			- 所有字符串都是String类型，String类型的数据需要使用引号引起来
		-Number(数值类型)
			-在JS中使用Number类型来表示一个数字,
			-所有的数字都是Number，包括整数和浮点数（小数）
			-在js中能表示的最大的数：1.7976931348623157e+308
			-如果超过这个数了，在JS中都是使用Infinity来表示，他表示正无穷。	
			-使用typeof检查Infinity和NaN也是返回number
			-还有一个特殊的数字:NaN(Not A Number),它用来表示一个非法的数字
		-Boolean(布尔值)
		-Null(空值)
			- null值用来表示一个为空的对象（Object）
			  所以使用typeof检查null值时会返回object
		-Undefined(未定义)
			- 它用来表示没有初始化的变量（仅仅声明而没有赋值）
	-一种引用数据类型为Object(对象)
2.类型转换
	-基本数据类型之间可以相互转换
		-将其他的数据类型转换为字符串
			-第一种调用tostring()方法，但是null和undefined不适用
			-第二种调用String()函数，支持其他的所有基本数据类型
			-第三种直接给其他数据类型后面加“”，推荐使用
		-将其他数据类型转换为数值类型
			-第一种调用Number()函数，支持所有其他的基本数据类型之间的转换
				-字符串：
					如果是一个纯数字的字符串，则直接转换为数字。
					如果字符串中含有非数字的内容，则直接转换为NaN。
				- 布尔值：
					如果值是true，则转换为1
					如果值是false，则转换为0
				- null会被转换为0
				- undefined会被转换为NaN
			-第二种调用parseInt()函数，只支持将字符串转换为整数，只取字符串的前边数字部分
				在parseInt中可以指定第二个参数，来说明数字的进制
			-第三种调用praseFloat()函数，只支持将字符串转换为小数，
		-将其他数据类型转化为布尔值
			-使用Boolean()函数
				- 情况：
				- 字符串：
					1.所有的非空字符串都会转换为true
					2.空串会转换为false
				- 数字：
					除了0和NaN其余的都是true。
				- null和undefined
					都会转换为false
			 	- 对象
					转换为true
3.隐式转化
	-将其他类型的数据类型转化为字符串
		为一个值+“”
	-将其他类型的数据类型转换为数字
		为一个值加+
	-将其他类型的数据类型转换为布尔值
		为一个值加！！
4.运算符（操作符）
	4.1二目运算符
		+	任何值和字符串相加，都会转换为字符串，然后转化为拼串操作
			任何值和NaN计算都等于NaN
			除了字符其他的数据类型都会转化为Number然后再计算
		-		/	任何的值做减法，乘法，除法 都会将其转换为Number进行计算
		%	可以对符号两侧的值进行取模的运算，就是取余数
		二元运算符，都不会对原变量的值进行修改，而只是将结果返回
	4.2自增和自减
		在自身的基础上增加一个1表示自增
			- 每自增一次原变量就会多加一个1
			- 自增使用 ++ 来表示，分为前++和 后++
			- 后++
					a++
			- 前++
					++a
			- 无论是前++还是后++，执行以后，原变量立即自增1。
					不同的a++和++a的值不同
					后++的值是变量自增以前的值
					前++的值是变量自增以后的值
			 自减
			 - 在自身的基础上减去一个1，表示自减
			 - 自减使用--，分为前-- 和 后--
			 - 无论是前-- 还是 后--都会使原变量自减1
				不同的是，后--是变量自减以前的值
				而前-- 是变量自减以后的值
			自增和自减都会改变原值
	4.3逻辑运算符
		！ 非	true变成false， false变成true
			对于非布尔值进行运算的情况，会先将其转换为布尔值然后在取反
		&&	JS中的&&是短路的与，一旦通过第一个值已经可以判断出结果了，	
		||	在js或也是短路的或，如果通过第一个已经可以判断出结果了，就不会在去看第二个值
		简而言之就是与运算就是找false，或运算就是找true
	4.3赋值运算符
		 赋值元素符
			= 
				- 可以将符号右侧的值赋值个符号左侧的变量
			+=
				例子： a+=5  等价于 a=a+5
			-=
				例子： a-=5  等价于 a=a-5
			=
				例子： a=5  等价于 a=a5
			/=
				例子： a/=5  等价于 a=a/5
			%=
				例子： a%=5  等价于 a=a%5
	4.4关系运算符
		关系运算符用来比较两个值之间的大小等于的关系，
			如果关系成立则返回true
			如果关系不成立则返回false
		当使用非Number进行比较时，会向将非Number转换为Number然后在比较	
		当使用关系运算符比较两个字符串时，它会去比较字符串的Unicode编码，
			然后返回结果。当字符串中包含多个字符时，会将他们每位分别进行比较,
			如果两位相等，则比较下一位，直到比出结果，当我们需要将内容按照字母顺序排序时，则可以使用关系运算符进行比较
		但是注意的是，如果比较的字符串是纯数字或中文，这种比较是没有意义的	
	4.5相等与全等
		相等运算符，可以判断符号两侧的值是否相等
			如果相等则返回true，不相等则返回false
			相等运算会默认对符号两侧的值进行类型转换，如果类型转换后相等，它也会返回true
		特殊情况：
			NaN不跟任何值相等，甚至不和自己相等
			由于undefined这个值衍生自null，所以为这两个值做相等判断时会返回true
			undefined和null相等，但是不全等
		全等运算符，可以判断符号两侧的值是否全等
			他和相等类似，不同的是他不会进行自动的类型转换，
			可以使用一个函数来判断一个值是否是NaN
			isNaN() 它可以用来判断一个数字是否是NaN，如果是则返回true，否则返回false
	4.6条件运算符，三元运算符，三目运算符
			- 语法：
				表达式1?表达式2:表达式3
			- 三元运算符在执行时，
			 	会先对表达式1的值进行判断，
				如果表达式1的值为true，则执行表达式2并返回执行结果
				如果表达式1的值为false，则执行表达式3并返回执行结果
5.流程控制语句
	5.1条件判断语句
		语法一:
			if(条件表达式){
			语句...
			}
		 语法二:
			if(条件表达式){
				语句...
			}else{
				语句...
			}
		- 当if...else...执行时，会先对if后的条件表达式进行求值，
			如果值为true，则执行if后的语句
			如果值为false，则执行else后的语句
		语法三:
			if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else if(条件表达式){
				语句...
			}else{
				语句...
			}
	5.2条件分支语句
		 （switch语句）
			语法：
			switch(条件表达式){
				case 表达式1:
					语句...
					break;
				case 表达式2:
					语句...
					break;
				default:
					语句...
					break;
			}
			当switch...case...语句执行时，
			会依次将case后的值和switch后的值进行比较，
			如果这两个值是全等的，则会执行case后边的所有语句，
			如果不全等，则继续向下判断。
			如果所有的case的判断都不成立，则执行default后的语句
		
			一旦case的条件成立，则case后的所有语句都会执行，包括其他case后边的，
			如果不希望执行其他case后的语句，则可以在语句的最后添加break,
			使用break可以立即跳出switch语句
	5.3循环语句	
		while循环
			语法：
			  	while(条件表达式){
			  		语句...
			 	}
			  	- 当while循环执行时，先对条件表达式进行判断，
			  		如果结果为true，则执行循环体中的语句，
			  		语句执行完毕以后，继续判断条件表达式
			  		如果为true，则执行循环体中的语句，如果为false则停止循环
		do...while循环
			语法：
				do{
					语句...
				}while(条件表达式)
			  
			  	- do...while...语句执行时，会先执行do后边的循环体，
			  		循环体执行完毕以后，在去判断while后的条件表达式，
			  			如果表达式结果为true，则继续执行，否则停止循环
			  
				- while和do...while...基本一致，
			  		不同的是while是先判断后执行，而do...while...先执行后判断
			  		do...while...可以保证循环体至少执行一次，而while不行
		for循环
			①初始化表达式
			②条件表达式
			③更新表达式
			语法：
				for(①初始化表达式;②条件表达式;④更新表达式){
			  			③语句...
					}
			  
				for循环执行的流程：
					①执行初始化表达式，初始化一个变量
					②执行条件表达式，判断条件，
						如果条件判断成立，为true，则执行循环体③
							循环体执行完毕，执行更新表达式④
							更新表达式执行完毕，重复②】
						如果为判断不成立，为false，则停止循环
				for循环的初始化表达式只会执行一次
				for循环中的三个表达式可以省略，也可以写在外边
	5.4break和continue
		break
			  	使用break可以用来跳出switch和循环语句,
			  	使用break语句，可以立即跳出离他最近的循环（停止循环）
		continue	
			  	使用continue可以跳过当次循环,
			  	continue也可以通过label来跳过指定的循环
	5.5计时器
		console.time()用来开启一个计时器，这个方法中需要一个字符串作为参数，这个字符串是计时器的标识	
		console.timeEnd()方法可以用来停止一个计时器
6.对象
	理解：可以理解为存储在内存中的对复杂数据的打包封装
	属性名必须是字符串格式，但是我们平时只需要直接写就行，不用专门为其加双引号。系统默认会解析成字符串
	6.1对象的分类：	
		1.内建对象
			- ES标准内置的对象
			- 比如：String Number Boolean Math RegExp...
		2.宿主对象
			- 指由JS运行环境提供的对象，目前主要指由浏览器提供的对象
			- 比如：document window .... BOM和DOM对象
		3.自定义对象
			- 自定义指由我们自己定义的对象
	6.2对象的基本操作
		创建一个对象
		方法一：var obj              = new Object();
		方法二：（对象字面量）obj = {};
		var 变量  = {属性名:属性值,属性名:属性值,属性名:属性值,属性名:属性值},最后一个属性值不写逗号
		方法三：使用构造函数来创建一个对象
		例子：function Parson (name,age){
			this.name=name,
			this.age=age
		}
		var par1=new Parson ();
		
		为对象添加属性
			obj.name="关羽"；
			obj["name"]="关羽"；
		修改对象的属性（新值会覆盖旧值）
			obj.name="赵云";
		删除对象的属性
			delete obj.name;                                                                   
		查询对象的属性
			alert(obj.name);
		
		
	6.3基本数据类型和引用数据类型的区别
		基本类型中的值都是独立的，修改一个变量不会影响其他的变量
		引用数据类型，保存时数据的引用，修改一个变量可能会影响到其他的变量
	6.4内存结构
		计算机的内存可以分成两种结构：
			栈内存 和 堆内存 	
			1.变量和基本数据类型都是保存到栈内存中的
			2.当我们使一个变量等于另一个变量时，实际上是将变量的值，
			 	在另一个变量中又复制了一份.
			3.由于基本数据类型都是独立，所以修改一个变量不会影响另一个。
		    4.对象是保存到堆内存中，当我们使用new关键字创建对象时，
				会立即在对内存中开辟出一块空间，专门用来保存对象。
				变量在栈内存中会保存对象的内存地址。
		当使用相等比较两个对象时，实际上比较的是对象的内存地址，而不是对象具体值
	
7.检查一个对象中是否含有指定的属性
	使用in运算符，来检查一个对象中是否含有指定属性
	语法："属性名" in 对象
	如果对象含有该属性，则返回true，如果没有则返回false
	console.log("age" in obj2);	
8.枚举对象中的所有属性
	使用for...in...语句
	该语句会执行多次，有几个属性就执行几次，
	每次执行时都会将对象中的一个属性名，赋值给对象前的变量，
	例子：	for(var n in obj){
				console.log(obj[n]);
			}
9.函数
		函数也是一个对象，只不过是一个功能更强大的对象，它除了可以在对象中添加属性以外，还可以保存代码
		使用typeof来检查函数的类型时，输出function
	9.1函数的创建方法
		第一种：利用构造函数进行创建
			var fun = Function{"alert('hello')"};
		第二种：使用函数声明表达式来创建一个函数
			function fun (形参){
				alert("hello");
			}		
		第三种：匿名函数
		var fun=	function (形参){
				alert("hello");
			};
	9.2函数的调用
		函数的引用();
		函数中封装的代码不会立即执行，只有在函数引用之后才会执行，并且为该函数开辟函数执行环境
	9.3形参和实参
		形参是变量，实参是数据
		当实参的数量小于形参时，则没有实参对应的形参将会是undefined;
	9.4返回值
		如果在函数中不知道返回值，则返回undefined;
		如果只写一个return，也返回undefined；
		我们在调用函数时，可以创建一个变量用来接收函数的返回值
	9.5作用域
		作用域，指的是JS代码的作用范围.
			1. 就是一块"地盘", 一个代码段所在的区域, 它是静态的(相对于上下文环境对象)
			2. js默认就有全局作用域, 其它作用域都是函数作用域,没有块级作用域
			3. 全局作用域在一开始编写JS代码时就确定了, 不是在运行时
			4. 函数作用域是在定义函数时就确定了, 不是在运行时
			5. 作用域的作用
				最大的用处就是隔离变量，不同作用域下同名变量不会有冲突
		在JS中作用域一共分为两种：
			全局作用域
				- 凡是直接写在script标签中的JS代码全都在全局作用域中
				- 一个页面中只有一个全局作用域
				- 全局作用域中的所有的变量和函数可以在页面的任意位置访问
				- 全局作用域有一个全局对象，叫做window
				- 一个页面中只有一个window对象，它代表整个的浏览器的窗口
				- 在全局作用域中创建的变量都会作为window对象的属性保存
						在全局作用域中创建的函数，都会作为window对象的方法保存
			  			
			函数作用域
				- 在函数中定义，并且执行的代码在函数作用域中
			  	- 函数作用域会有多个，函数执行几次就有几个函数作用域
				-函数作用域在函数开始执行时创建，在函数执行完毕之后销毁。
			  	- 函数每次执行时都是一个独立的作用域 
			  	- 在函数作用域中声明的变量，是局部变量，只在当前函数作用域中起作用，
			  		在函数的外部，不能访问内部的变量。
			  		在函数内部可以访问外部的变量
			  	- 在函数中不使用var关键字声明的变量，都会变成全局变量
			  	- 如果全局和函数作用域中有同名的变量，会优先使用函数中的变量（谁近用谁）
			  	- 在函数作用域中可以通过window来访问全局变量
			  	- 在函数作用域中，变量和函数也会声明提前。
			  	- 形参就相当于在函数中声明了变量
	9.7上下文执行环境
		上下文环境的理解
        1. 也称执行上下文环境
        2. 本质是一个对象,由js引擎自动帮我们创建, 但它对我们是透明的, 我们只能直接使用其属性
        3. js引擎在执行全局代码段会先做些"准备工作"
            1). 将Global对象(window)作为全局上下文环境对象
            2). 将一些变量进行初始化赋值
                var 定义的变量都会预先定义，值为undefined
				会把整个函数进行预加载
            3). 将它们设置为上下文环境对象(window)的属性
        4. js引擎在执行函数体之前也会先做些"准备工作"
            1). 创建函数上下文环境对象
            2). 将一些变量进行初始化赋值
				将函数内部的var定义的变量预先定义，值为undefined
            3). 将它们设置为上下文环境对象的属性
         5. 变量提升与函数提升
             1). 变量提升
                 通过var定义的变量, 在定义语句之前就可以访问到
                 值: undefined
             2). 函数提升
                 通过function声明的函数, 在之前就可以直接调用
                 值: 函数定义(对象)
		 执行上下文环境分类
			1. 全局上下文环境
				1). 初始化时间
					在全局js代码开始执行之前生成
				2). 初始化工作
					var定义的全局变量(任意类型值)――变量声明，默认赋值为undefined
					使用function声明函数――赋值(函数定义)
					this――赋值(window)
			2. 函数上下文环境
				1). 初始化时间
					在调用函数时, 函数体执行前之前生成
				2). 初始化工作
					var定义的变量(任意类型)――变量声明，默认赋值为undefined
					函数声明――赋值(函数定义)
					this――赋值(调用函数的对象)
					形参变量----赋值(实参)
					arguments----赋值(实参列表伪数组)
	9.6函数和方法
		当一个对象的属性是一个函数时，我们称这个函数是这个对象的方法 
			 对象.方法()
			 - 调用一个对象的什么什么方法
			 函数()
			 - 调用了一个函数
	
	9.7this关键字(函数的执行的上下文对象)
			this的情况：
				1.当函数作为一个方法调用时，谁调用的函数this就是谁。
					列子：obj.fun()--> this 就是obj
				2.当作为一个函数调用时，this永远都是window
					列子：fun() --> this 就是window （window.fun()）
				3.当作为一个构造函数调用时，this就是新创建的那个对象
					列子：var par = new person() --> this --> per
				4.当以call或apply调用一个函数时，第一个参数就是this
	9.8构造函数
			构造函数和普通函数的创建方式一样，只不过构造函数的名字首字母大写,
				而且调用构造函数时，需要使用new关键字。
			构造函数的执行流程：
			  	1.立刻创建一个新的对象
			    2.将新建的对象作为函数执行时的this
			    3.执行函数中的代码
			    4.将新创建的对象返回
	实例------->实例也是对象，就是指调用相同构造函数的对象
				例子：var par1 =new Parson();
					  var par2 =new Parson();
				这里par1和par2都是Parson这个构造函数的实例
				在这里，this指的就是实例，但是this与实例并不是全等的
	9.9立即执行函数
		（function(){
		}）（）；
		立即执行函数一定是一个匿名函数，它是将整个函数作为函数的引用，因为它没有名字，可以把本身作为自己的引用
	9.10回调函数
		由我们定义，但是最终不由我们自己调用的函数，我们称为回调函数。
	9.11 函数对象的方法
			  call() 
			  apply()
					- 这两个方法是函数对象的方法，需要通过函数对象来调用
							apply方法和call类似，也可以用来指定函数执行时的this
					使用这两个方法可以用来设置函数执行的时this，想让this是谁就传谁 
					使用call方法，可以在对象后面继续设置参数，这些参数将会作为函数执行时的实参
					apply不支持这种传参方式，apply方法需要将实参封装为一个数组，来传递
	9.12两个隐含的参数：
		1.this 函数执行的上下文对象
		2.arguments 实参的数组
			- 这个对象是一个类数组对象
			- 无论我们的函数中是否定义形参，
				调用函数时传递的实参都会保存到arguments对象中
				实际上这个对象就是用来保存实参的
			- 通过arguments即使不定义形参也可以任意的获取实参 
			- arguments对象中还有一个属性：
				callee
					 - 这个属性指向的是一个函数对象，
						这个函数就是当前正在执行的函数对象
	9.13创建函数的目的：
		 		1. 运行。完成具体商业逻辑：加法器，向服务器发送数据，等
		 		2. 构造。负责构造对象，通常和 new 关键字配合使用。
						
10.原型（prototype）
		1.当函数作为普通函数调用时，原型并没有作用
		2.当函数作为构造函数调用时，它可以创建对象，它所创建的对象也会有一个隐藏的属性指向原型对象
			当我们去读取一个对象中的属性或调用对象中的方法时，
				它会优先去对象本身里寻找属性和方法，如果对象本身中没有，
				则它会去对象的原型中寻找
				Object对象是所有的对象的祖先，所有的对象都衍生在Object，
			  		Object对象的原型没有原型
		3.函数的 prototype 属性
             1.1). 每个函数都有一个 prototype 属性, 它默认指向一个对象(原型对象)
             1.2). 原型对象中有一个属性 constructor, 它指向函数对象
             1.3). Object 的原型
                 Object 实例对象的方法都定义在 Object 的原型对象中
                 Object 的原型对象的原型为 null (没有父对象)
                    Object.prototype.__proto__ === null
					
		原型的应用：tostring()方法，tostring方法并没有被定义，但是当我们在用console.log和alert()输出一个对象时，它会将输出的内容以字符串的形式显示，
			其底层其实是应用了tostring（）方法，那么tostring方法就是被定义在了对象的原型中了
11.数组（array）
		使用typeof来检查数组的类型时，输出object
		创建方法：
		方法一：构造函数来创建
			var arr = new Array();
		方法二：用对象字面量的方式来创建
			var arr = [];
		数组中的元素可以是任意类型，包括对象以及函数
		向数组中添加元素
		语法：arr[索引] = 值;
		length属性
			 	- 对于连续的数组，通过length属性可以获取到数组中元素的个数
			 	- 对于非连续的数组，通过length属性可以获取到数组中 最大的索引+1
	10.1数组的基本操作方法
		push:为数组末尾添加元素，并且返回新的长度
		pop:为数组末尾删除元素，并且返回删除的元素
		shift:为数组最前端删除元素，并且返回删除的元素
		unshift：为数组的最前端添加元素，并且返回新的长度
		会改变原来数组的有：
		splice()
					- 用于删除数组中指定元素，并且会将删除的元素封装为一个新的数组并返回
				参数：
			  		第一个
			  			表示开始删除元素的索引
			  		第二个
			  			表示删除的个数
				splice可以使用新的元素替换元素，
			  	只需要在第二个参数后，在跟着新的元素，则可以使用新元素替换原有元素的位置 
				如果第二个参数是0，则可以在指定的元素前边插入新元素
		reverse()
			  	- 用来颠倒一个数组，前边的去后边，后边去前边
			 	- 该方法会直接在原数组中修改
		sort()
				为数组进行排序，我们一般为sort()方法中的参数设置一个回调函数来自己定义排序的方法	
				升序排列  return a-b;
				降序排列  return b-a;
		join()
				可以用来将一个数组中的所有的元素转换为一个字符串
				join()中可以指定一个字符串作为参数，
					这个字符串将会作为连接符来使用
				如果不指定连接符，则默认使用,连接
		不会改变原来数组的有：
		slice()
			可以用于获取一个数组中的一个子数组
				第一个：表示截取开始位置的索引，截取时会包括开始位置的元素
				第二个：表示截取结束位置的索引，截取时不会包括结束位置的元素
		concat()
			用来连接两个或多个数组
		
		
	10.2数组的遍历
		方法一：遍历数组一般我们都会通过一个for循环来变量数组
			for(var i=0 ; i<arr.length ; i++){
				console.log(arr[i]);
			}
		方法二：forEach()
			  	- 这个方法可以用来遍历一个数组中的所有的元素
			  	- 该方法需要一个函数对象作为参数
				forEach()中的回调函数会执行多次，
			  		数组中有几个元素就会执行几次函数
				浏览器在调用我们这个回调函数会传递进来三个参数：
			 		第一个
			  			- 表示当前遍历到的元素的值
			 			- 第一次执行，第一个参数就是第一个元素
			  				第二次执行，第一个参数就是第二个元素
			 		第二个
			  			- 表示当前遍历到的元素的索引
			 		第三个
			  			- 表示当前正在遍历的数组对象
11.Math对象
	Math对象并不是一个构造函数，并不能创建对象。它只是一个工具，可以直接使用
	方法：
		ceil()可以对一个数进行上舍入， 	只要小数有值就进1
		floor()可以对一个数进行下舍入，所有的小数部分都被舍掉
		round()可以对一个数进行四舍五入的运算
		random()可以用来随机生成一个0-1之间的数字
		生成x-y之间的随机数
	 		Math.round(Math.random()(y-x)+x) 	
12.Date对象
		Date用来表示一个时间的对象
		可以创建一个指定的时间，需要在Date的构造函数中传递一个指定时间的字符串
			格式     月份/日期/年份 小时:分钟:秒数
			例子：d = new Date("11/12/1895 20:30:00");
		方法：
			getDate()获取当前日期对象是几日
			getDay()获取当前日期对象时周几
			getMonth()可以用来获取当前日期的月份，它会返回一个0-11的数
			getFullYear()可以用来获取当前日期的年份
			getTime()
			  	- 可以用来获取当前Date对象的时间戳
			  	- 时间戳指从格林威治标准时间1970年1月1日0时0分0秒，到现在这个时间所花费的毫秒数
			  	- 在计算机底层所哟肚饿时间都是以时间戳的形式保存
			Date.now() 可以用来获取当前的时间戳
			toLocaleString()
			  	- 可以将时间转换为本地的格式
				- 这个格式在不同的浏览器中显示的效果不一致，所以如果需要统一效果，
			  		最后手动设置日期
13.包装类
	在ES标准中，还提供了三个包装类String Boolean Number
			  	使用这三个包装类可以将一个基本数据类型的数据转换为一个对象 
				当我们操作一个基本数据类型属性或者是调用基本数据类型的方法时，
			  	解析器会临时将其转换为对象，然后在完成相关的操作，
				操作完成以后，在将对象变回基本数据类型
14.大量的字符串方法
			var str ="Hello World"
			str.charAt(3);   
		//charAt()获取一个字符串中指定位置的字符，参数传的是这个字符串的索引
			console.log(str.charAt(3)) //l
		//charCodeAt()可以根据索引来获取指定位置的字符的字符编码
			console.log(str.charCodeAt(3)); //108
		//fromCharCode()可以将字符编码转化为一个字符,该方法只能用string来调用
			console.log(String.fromCharCode(108)); // l
		//concat()可以将多个字符串进行拼接，就是拼串
			console.log(str.concat(" nihao"));  //Hello Worlde nihao
		//indexOf()检索出指定字符串在原字符串中首次出现的位置，可以设定第二个参数，用来指定在什么位置开始找
			result=(str.indexOf("e",4));
			console.log(result); 			//-1	未找到
		//lastIndexOf()和indexof方法一样，只是从后往前检索
			console.log(str.lastIndexOf("e",4));	//1		
		//slice()用来截取字符串，第一个参数用来设置截取的起始位置，第二个参数用来设置截取的结束位置，但是截取的部分不包括结束位置
			console.log(str.slice(2,5));	//	llo
		//substring()用来截取字符串，和slice一样，只是当你输入的两个参数第二个比第一个大的时候，它会自动调节位置，并且不接收负值
			console.log(str.substring(5,2)); 	//llo
		//search() 可以从一个字符串中搜索指定的字符串，参数设置为正则表达式，则根据正则表达式搜索
		//不能使用g全局匹配
			console.log(str.search(/e/));	//1
		//match()方法可以将字符串中所有符号正则表达式的要求的内容提取出来；默认只会找到第一个符合就停止，我们
		//可以通过修改匹配模式来设置全局查找
			console.log(str.match(/e/g));	//e ,e 
		//replace()可以用来将一个字符串中的内容替换为其他内容，第一个参数查找要替换的对象，可以是正则表达式
		//第二个参数用来设置要替换的内容
			console.log(str.replace(/e/g,"你")) //H你llo World你
		//split()可以设置指定内容将字符串拆分为数组
			console.log(str.split(/e/)); 	//H,llo World,				
15.正则表达式(RegExp)			
		15.1正则表达式就是用来定义一些字符串的规则的，		
			通过正则表达式可以用来检查一些字符串是否符合某种规则。	
			正则表达式的对象中可以传递两个参数
				var reg = new RegExp("正则表达式","匹配模式");	
			匹配模式主要有两种模式：
				i：忽略大小写
				g：全局匹配
		15.2运算符
			[]中的字符都是或的关系
				  [abc] === a|b|c	
				  [a-z] 表示任意的小写字母
				  [A-Z] 表示任意的大写字母	
				  [A-z] 表示任意的字母	
				  [0-9] 表示任意数字
				  [^ ] 除了这里边的内容
		15.3量词
			{m,n} 出现m-n次
			{m,} 至少出现m次	
			+表示至少一个，相当于{1,}	
			可以有0个或多个，相当于{0,}	
			?可以有0个或一个，相当于{0,1}
			^表示以什么什么开头
			$表示以什么什么结尾
		15.4特殊字符
			正则中.表示任意字符
			  	在正则中可以使用\来对特殊字符进行转义
		 	    \.就是表示. 
		 	  	\\就表示 \
				\w 表示单词字符，包括字母 数字 下划线 [A-z0-9_]
				\W 除了字母 数字 下划线 [^A-z0-9_]
				\d 表示任意数字 [0-9]
				\D 除了数字 [^0-9]
				\s 表示空格
				\S 表示除了空格
				\b 单词边界
				\B 除了单词边界
16.DOM(document object model)文档对象模型
	我们希望当某个事件被触发时，可以执行一段JS代码来响应事件
	可以通过为对象的指定事件属性来绑定回调函数的形式来响应事件
	window的onload事件将会在整个页面加载完成之后触发,
			  	我们可以将需要执行的代码放到该事件的回调函数当中，
			  		这样可以确保我们的代码可以在整个页面加载完成之后才执行，
			  		这样就不会出现获取不到dom对象的情况了
16.1节点
	Node--构成HTML文档最基本的单元
		-文档节点：整个HTML文档
		-元素节点：HTML文档中的HTML标签
		-属性节点：元素的属性
		-文本节点：HTML标签中的文本内容
16.2事件
	事件：就是文档或浏览器窗口中发生的一些特定交互瞬间
	Javascript与HTML之间的交互是通过事件实现的
16.3DOM查询
	16.3.1获取元素节点
		通过document对象调用
		1.getElementById(字符串)
			-通过id属性获取一个元素节点对象
		2.getElementsByTagName(字符串)
			-通过标签名获取一组元素节点对象
		3.getElementsByName(字符串)
			-通过name属性获取一组元素节点对象
		4.使用CSS选择器进行查询节点
		  querySelector(字符串)
		  querySelectorAll(字符串)
			这两个方法都是用document对象来调用，两个方法相同。都是传递一个选择器字符串作为参数
			不同的是querySeletor()只会返回找到的第一个节点，而querySelectorAll()会返回所有符合条件的元素
		5.getElementsByClassName()可以根据class属性值来获取一组元素节点对象，
			但是它不兼容IE8及以下的浏览器
	16.3.2获取元素节点的子节点
		通过具体的元素节点调用
		1.getElementsByTagName()
		-方法，返回当前节点的指定标签名子节点
		2.childNodes		children
		-属性，表示当前节点的所有子节点
		3.firstChild
		-属性，表示当前节点的第一个子节点
		4.lastChild
		-属性，表示当前节点的最后一个子节点
		5.parentNode
		-属性，表示当前节点的父节点
		6.previousSibling
		-属性，表示当前节点的前一个兄弟节点
		7.nextSibling
		-属性，表示当前节点的后一个兄弟节点
16.4DOM增删改
	创建一个元素节点
		createElement()可以用来根据标签名创建一个新的元素节点，并将新建的节点返回
	创建一个文本节点
		createTextNode()可以根据一个字符串创建一个文本节点，并将新的节点返回	
	向一个父节点中添加一个新的子节点
		appendChild()
		父节点.appendChild(子节点)
	将一个子节点插入到指定的字节前边
		insertBefore()
		父节点.insertBefore(新节点,旧节点)
	替换节点
		父元素.replaceChild(新节点,旧节点)
	 	可以使指定的节点来替换一个旧节点
	删除节点
		子元素.parentNode.removeChild(子元素)	
16.5conform确认框
		confirm()可以用来弹出一个确认框
		该方法有一个返回值，如果用户点击确认则返回true，否则返回false
17.用JS操作CSS样式
		17.1修改元素的CSS样式：
			语法：
				元素.style.样式名  = "样式值";
		17.2读取元素的CSS样式
			在正常的浏览器中，可以使用getComputedStyle(obj，null)来获取，这是一个方法
			在IE8及以下的浏览器中，只能使用currentStyle，这是一个属性，对象.currentStyle
			这两种方式获取到样式的对象都是只读的，不能通过他们修改样式		
		17.3其他的样式的读取：
			元素.clientWidth
			元素.clientHeight
				- 获取元素的可见框的大小（包括内容区和内边距，不包括边框）
			元素.offsetWidth
			元素.offsetHeight
				- 获取元素的可见框的大小，和上边不同的是他们包括边框
				
			offsetParent
				- 获取当前元素的定位元素
				
			offsetTop
				- 获取当前元素相对于其定位元素的垂直偏移量
				
			offsetLeft
				- 获取当前元素相对于其定位元素的水平偏移量
				
			scrollHeight
			scrollWidth
				- 获取当前元素整个滚动范围的宽度和高度
				
			scrollTop
			scrollLeft
				- 滚动条垂直和水平方向滚动的距离
				
			注意：以上几个属性返回的值都是Number类型，不带px，可以直接计算

			判断滚动条是否滚动到底：
				垂直方向：scrollHeight - scrollTop == clientHeight;
				水平方向: scrollWidth - scrollLeft == clientWidth;
				
			onscroll --> 元素滚动条滚动的实际
18	return false;
	如果不希望页面跳转，可以来取消它的默认行为
	直接在响应函数的最后return false即可	
	取消默认行为也可以用event.preventDefault()
19 冒泡
		简单来说冒泡指的就是事件的向上传导，
		当我们触发后代元素上的某个事件时，同时也会触发其祖先元素上的相同事件
	取消冒泡的方法
		event.cancelBubble = true;
20事件
	clientX和clientY用来获取鼠标在当前页面相对于浏览器窗口的坐标，而不是相对于整个页面的坐标
	20.1事件的委派
			所谓的事件委派，指当需要为多个元素绑定响应函数时，
				可以将这些事件统一绑定给他们共同的祖先元素上，
				这样当后代元素的事件触发以后，将会冒泡到祖先元素，触发祖先元素上的事件，
				这样我们只需要为一个祖先元素绑定，所有的后代都会拥有相同的事件处理函数
		ul.onclick = function(event){
					
					event = event || window.event;
					
					//事件对象event中具有一个target属性，表示触发事件的元素 
					//alert(event.target.nodeName);
					//只有点击的是超链接时，才执行以下代码，其他的元素都不会执行
					if(event.target.nodeName == "A"){
						alert("我是ul上的单击响应函数");
					}
				};	 
	20.2事件的绑定
		通过元素的addEventListener()方法，来为一个元素绑定响应函数
		参数：
			1.需要一个事件的字符串(不加on)
			2.回调函数，当事件被触发时，要执行的函数
			3.需要一个布尔值，是否需要在事件捕获阶段触发事件，一般都传false
		但是IE8及以下的浏览器中，不支持addEventListener这个方法
		在这些浏览器中可以使用attachEvent()来绑定处理函数
		参数：
			1.事件名字的字符串（需要on）
			2.回调函数，当事件触发时将会被调用
	20.3事件的传播
		W3C规定，事件分为三个阶段进行
		1.捕获阶段
		2.目标阶段
		3.冒泡阶段
			如果需要在捕获阶段执行响应函数，则可以将addeventListener()中的第三个参数修改为true。
	20.4完成拖拽
		这里用到了三个事件
		1.onmousedown	鼠标按下时，物体开始移动
		2.onmousemove	物体跟随鼠标指针移动
		3.onmouseup		鼠标松开时，物体停止移动
	20.5滚轮事件
		onmousewheel是鼠标滚轮滚动的事件，当鼠标滚轮滚动时会触发该事件
			但是该事件并不支持火狐浏览器，在火狐中需要使用DOMMouseScroll
			来绑定鼠标滚动滚动事件，而且该事件必须通过addEventListener()来绑定				
		这里用到bind函数，可以实现在火狐中利用addEventListener()
			例子：var box1 = document.getElementById("box1");
				
				//为正常浏览器绑定
				box1.onmousewheel = function(event){
					event = event || window.event;
					if(event.wheelDelta < 0 || event.detail > 0){
						box1.style.height = box1.clientHeight + 10 +"px";
					}else{
						box1.style.height = box1.clientHeight - 10 +"px";
					}
					/
					  当页面中具有滚动条时，由于默认行为会导致滚动条滚动，
					  	我们不希望滚动条滚动，可以通过return false来取消默认行为
					  
					  在火狐中通过addEventListener()绑定的响应函数，
					  	通过该方法绑定的相遇函数，不能使用return false来取消默认行为
					  	而是需要通过event的preventDefault()方法来取消默认行为
					 /
					event.preventDefault && event.preventDefault();
					return false;
				};
				//为火狐绑定
				bind(box1,"DOMMouseScroll",box1.onmousewheel);
				//bind 函数
				function bind(obj , eventStr , callback){
					if(obj.addEventListener){
						obj.addEventListener(eventStr , callback , false);
					}else{
						obj.attachEvent("on"+eventStr , function(){	
							callback.call(obj);
						});
					}
				}
	20.6键盘事件
			onkeydown：按键按下的事件
			onkeyup：按键松开的事件
				通过event.keyCode可以来获取按下按键的编码
					还有三个属性
						  	altKey：判断事件触发时alt是否被按下，如果按下则返回true，否则返回false
						  	ctrlKey: 判断ctrl键是否被按下
						  	shiftKey：判断shift键是否被按下
21	BOM(浏览器对象模型)					  
		BOM中为我们提供了一组对象用来对浏览器进行各种操作
			- window
				- 代表浏览器的窗口，也是全局对象
			- navigator
				- 封装了浏览器的信息，通过该对象可以识别不同的浏览器
			- history
				- 封装了当次浏览器的历史记录，由于隐私的原因，该对象不能访问具体的历史记录
					只能控制浏览器向前或向后跳转页面
			- location
				- 封装了浏览器的地址栏信息，通过该对象可以操作浏览器跳转到不同的页面
			- screen
				- 用户的显示器的信息，暂时用不到	
	21.1	navigator
					- 代表的是当前浏览器的信息，通过该对象可以获取到浏览器的版本
					- 由于历史原因navigator中的大部分属性都不能用来判断浏览器的信息
					- 唯一一个可以用来判断浏览器版本的属性，就是userAgent（用户代理）
						该属性中保存的是一个字符串，字符串中含有当前的浏览器信息，
						不同的浏览器会保存不同信息，通过该字符串就可以来识别不同的浏览器
	21.2	history	
				length可以获取当次历史记录中地址的数量
				back()可以用来回退一个页面，相当于浏览器的回退按钮
				forward()向前跳转一个页面，相当于浏览器的前进按钮
				go()方法需要一个整数作为参数
					  	如果参数为整数，则会向前跳转指定数量的页面
					  	如果参数为负数，则会向后跳转指定数量的页面
	21.3	location
				location表示浏览器的地址栏信息，通过该对象可以用来任意的操作浏览器地址栏，来跳转页面
				assign()中需要一个地址作为参数，可以直接跳转页面和直接修改location的效果一样,会生成历史记录
				replace()和assign()用法一致，都用来跳转页面，不同的是该方法不会生成历史记录
				reload()用来刷新页面，相当于浏览器的刷新按钮
					该方法中可以传递一个true，如果传递了true，则默认会强制清空缓存刷新
22.定时调用
	setInterval(function(){},时间)
		- 可以每隔一段时间就调用指定的函数一次
		- 参数：
			1.回调函数，该函数将会每间隔一段时间调用一次
			2.间隔的毫秒数
	clearInterval()可以用来停止一个定时器，
				  	该方法需要一个定时器的标识作为参数，标识对应的定时器将会立即被停止
					标识就是定时器的名字
23延时调用
	在JS中还有一个和定时调用类似的功能叫做延时调用，
			所谓的延时调用只的是函数不会立即执行，而是隔一段时间以后再执行
			使用setTimeout()方法开启延时调用，它的用法和setInterval()一致
				他们的区别就是setInterval()中的函数会反复执行多次，
				而setTimeout()中的函数只会执行一次
			
			这两个方法本质上没有任何区别，可以使用setTimeout()代替setInterval()
				反过来也可以使用setInterval()来代替setTimeout()		
			clearTimeout可以用来终止延时调用
24JSON	(特殊的字符串)
	使用JSON可以来描述一个对象，使用JSON描述的对象可以在任意的语言中使用。
	像这样的字符串
		var str = '{"name":"孙悟空","age":18,"address":"花果山"}'; //JSON对象
	JSON的语法和JS对象的语法基本一致，只不过JSON对象中的属性必须使用""引起来
	在JSON中属性名必须加双引号！！！'
	JSON的值类型可以是{
		1.String;2.Boolean;3.Number;4.null;5.{};6.[]
	}
	JSON的转换
		将一个JSON字符串 转换 为JS对象
			JSON.parse()来将一个JSON字符串转换为一个JS对象
			该方法需要一个JSON字符串作为参数，会将该字符串转换为对象并返回
		将字符串转换为JSON字符串
			JSON.stringify()
			 	- 该方法可以将一个JS对象转换为一个JSON字符串
			  	- 需要一个对象作为参数，可以将该对象转换为JSON字符串并返回
25显示原型和隐式原型
	显示原型：prototype
	隐式原型：__proto__
	显示原型的值：原型对象
		所有的函数都有prototype这个属性，prototype的属性值是一个object（原型对象）,其中这个object（原型对象）有一个属性是constorction,它的值指向构造这个函数的Function,
		当这个函数是构造函数，用这个构造函数实例化（new）出来的对象，都有一个隐示原型__proto__，隐式原型指向的是构造函数的显示原型的值，即原型对象
	特例：
		1.Object的原型对象的隐式对象的值为null 	---->    Object.prototype.__proto__=== null;
		2.Function的隐式原型等于它的显示原型----->	Function.__proto__ === Function.prototype	
26.闭包
	定义：当一个嵌套的内部(子)函数引用了嵌套的外部(父)函数的变量(函数)时, 就产生了闭包
	理解： 理解一: 闭包是嵌套的内部函数(绝大部分人)
            理解二: 包含被引用变量(函数)的对象(极少数人)
            注意: 闭包存在于嵌套的内部函数中
	产生条件：1.函数嵌套。
			  2.内部函数引用了外部函数的数据（函数、变量）
	常见的闭包：
		 1. 将函数作用另一个函数的返回值
				function fn1() {
				var a = 2;
				function fn2() {
					a++;
					console.log(a);
				}
				return fn2;
			}
         2. 将函数作为实参传递给另一个函数调用
				 function showMsgDelay(msg) {
					setTimeout(function () {
					console.log(msg);
					}, 2000);
				}
	作用：  1. 使用函数内部的变量在函数执行完后, 仍然存活在内存中(延长了局部变量的生命周期)
			2. 让函数外部可以操作(读写)到函数内部的数据(变量/函数)		
	生命周期：
			1. 产生: 在嵌套内部函数定义执行完时就产生了(不是在调用)
				当外部函数一定义，就形成了闭包
			2. 死亡: 在嵌套函数成为垃圾对象时，如果需要释放闭包，需要把外部连着的变量设置为null,让闭包成为垃圾对象，等待回收
				function fun1() {
            //问题2: 此时闭包产生了吗?    //此时闭包已经存在了{a:undefined}
            var a = 3;
            function fun2() {
                a++;
                console.log(a);
            }
            return fun2;
			}
			//问题1: 此时闭包产生了吗?
			var f = fun1();
			//问题3: 此时闭包释放了吗?
			f();
			f();
			//问题4: 此时闭包释放回收了吗?
			//问题5: 如何让闭包释放回收呢?
			f = null;
	 缺点
             函数执行完后, 函数内的局部变量没有释放, 占用内存时间会变长
             容易造成内存泄露
     解决方案
             能不用闭包就不用
             及时释放			
27.全局对象window.globel。全局变量,属性。全局函数，方法		

28严格模式
	作用：	- 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为
			- 消除代码运行的一些不安全之处，保证代码运行的安全
			- 为未来新版本的Javascript做好铺垫
	语法和行为改变
	1. 必须用var声明变量
	2. 创建eval作用域     eval(里面如果传的是类似JS的字符串)，eval会自动将其解析为JS代码并且执行
	      ，这样当里面的字符串定义的变量和外面的变量重名时，会直接覆盖外面的变量，这样会很不安全
	3. 禁止this指向window
	4. 对象不能有重名的属性
	5. 函数不能有重名的形参
29.各个数据类型有用的扩展
	29.1.Object
		静态方法：由函数自己调用	函数自身的属性是个函数就是静态方法
		实例方法：由实例对象调用	添加实例对象的方法：1.在构造函数里面直接定义	2.为构造函数的原型对象添加方法
		29.1.1	Object.create()
					create第一个参数：继承对象
					第二个参数：添加属性:属性值可以设置成一个对象
					对象的参数：value:默认值
                   wireable:能否被修改,默认是true,可以被修改
		29.1.2	Object。defineProperties(): 为指定对象定义扩展多个属性
				参数一：指定的对象
				参数二：扩展的属性(一般是对象，里面放set,get方法)
		 get : //什么时候调用? 当读取当前属性值时自动调用
				//作用? : 返回当前属性的值
		 set : //什么时候调用? 当更新当前属性的值时(已经)
				//作用? : 监视当前属性值的变化, 就可以同步变化一些其它的值
	29.2 Array	
		1. Array.prototype.indexOf(value) : 得到值在数组中的第一个下标
		2. Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标
		3. Array.prototype.forEach(function(item, index){}) : 遍历数组
		4. Array.prototype.map(function(item, index){return (表达式:如 item+10)}) : 遍历数组返回一个新的数组,返回的数组和原数组的元素个数相同 ,return的表达式为true,就返回这个值
		5. Array.prototype.filter(function(item, index){return (表达式：如 item>5)}) : 遍历过滤出一个新的子数组，return的表达式为true,就返回这个值
	29.3 Function			
		面试题: 区别bind()与call()和apply()?
		  1.call()和apply()
			1.第一个参数指定函数中的this
			2.调用函数
		  2.bind()
			1.第一个参数指定
			函数中的this,即调用者
			2.返回函数
		  3.call()和apply()的区别
			call()从第二个参数之后，就是一个一个的传入实参
			apply()从第二个参数是一个实参数组
30.ES6新语法
1.let关键字
	与var类似, 用于声明一个变量
	特点:
     在块作用域内有效
     不能重复声明
     不会预处理, 不存在提升
## 理解ES
1. 全称: ECMAScript
2. js语言的规范
3. 我们用的js是它的实现
4. js的组成
   ECMAScript(js基础)
   扩展-->浏览器端
     BOM
     DOM
   扩展-->服务器端
     Node.js
      
## ES5
1. 严格模式
   运行模式: 正常(混杂)模式与严格模式
   应用上严格式: 'use strict';
   作用: 
     使得Javascript在更严格的条件下运行
     消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为
     消除代码运行的一些不安全之处，保证代码运行的安全
     需要记住的几个变化
       声明定义变量必须用var
       禁止函数中的this关键字指向全局对象
       创建eval作用域, 更安全
      
2. JSON对象
   作用: 用于在json对象/数组与js对象/数组相互转换
   JSON.stringify(obj/arr)
      js对象(数组)转换为json对象(数组)
   JSON.parse(json)
      json对象(数组)转换为js对象(数组)
      
3. Object扩展
   Object.create(prototype[, descriptors]) : 创建一个新的对象
     以指定对象为原型创建新的对象
     指定新的属性, 并对属性进行描述
       value : 指定值
       writable : 标识当前属性值是否是可修改的, 默认为true
       get方法 : 用来得到当前属性值的回调函数
       set(newValue)方法 : 用来监视当前属性值变化的回调函数
   Object.defineProperties(object, descriptors) : 为指定对象定义扩展多个属性
  
4. Array扩展
   Array.prototype.indexOf(value) : 得到值在数组中的第一个下标
   Array.prototype.lastIndexOf(value) : 得到值在数组中的最后一个下标
   Array.prototype.forEach(function(item, index){}) : 遍历数组
   Array.prototype.map(function(item, index){return xxx;}) : 遍历数组返回一个新的数组
   Array.prototype.filter(function(item, index){return true/false}) : 遍历过滤出一个子数组
  
5. Function扩展
   Function.prototype.bind(obj)
       将函数内的this绑定为obj, 并将函数返回
   面试题: 区别bind()与call()和apply()?
       fn.bind(obj) : 指定函数中的this, 并返回函数
       fn.call/apply(obj) : 指定函数中的this,并调用函数
       一个函数可以成为任意对象的方法调用 
6. Date扩展
   Date.now() : 得到当前时间值
  
## ES6
1. 2个新的关键字
   let/const
   块作用域
   没有变量提升
   不能重复定义
   值不可变
  
2. 变量的解构赋值 : 将一个对象/数组内部的多个数据解构出来一次性赋值给多个变量
   将包含多个数据的对象(数组)一次赋值给多个变量
   数据源: 对象/数组
   目标: {a, b}/[a, b]
  
3. 各种数据类型的扩展
   字符串
     模板字符串 
       作用: 简化字符串的拼接
       模板字符串必须用``
       变化的部分使用${xxx}定义
     contains(str) : 判断是否包含指定的字符串
     startsWith(str) : 判断是否以指定字符串开头
     endsWith(str) : 判断是否以指定字符串结尾
     repeat(count) : 重复指定次数
         
   对象
     简化的对象写法
      let name = 'Tom';
      let age = 12;
      let person = {
          name,
          age,
          setName (name) {
              this.name = name;
          }
      };
     Object.assign(target, source1, source2..) : 将源对象的属性复制到目标对象上
     Object.is(v1, v2) : 判断2个数据是否完全相等
     __proto__属性 : 隐式原型属性
     
   数组
     Array.from(v) : 将伪数组对象或可遍历对象转换为真数组
     Array.of(v1, v2, v3) : 将一系列值转换成数组
     find(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素
     findIndex(function(value, index, arr){return true}) : 找出第一个满足条件返回true的元素下标
   函数
     箭头函数
       用来定义匿名函数
       基本语法:
         没有参数: () => console.log('xxxx')
         一个参数: i => i+2
         大于一个参数: (i,j) => i+j
         函数体不用大括号: 默认返回结果
         函数体如果有多个语句, 需要用{}包围
       使用场景: 多用来定义回调函数
     形参的默认值
       定义形参时指定其默认的值
    扩展运算符(...)
       作用：
	   1.通过形参左侧的...来表达, 取代arguments的使用	（收集形参）
	   2.可以分解出数组或对象中的数据		（分解数组和对象）
    
4. set/Map容器结构
   容器: 能保存多个数据的对象, 同时必须具备操作内部数据的方法
   任意对象都可以作为容器使用, 但有的对象不太适合作为容器使用(如函数)
   Set的特点: 保存多个value, value是不重复 ====>数组元素去重
   Map的特点: 保存多个key--value, key是不重复, value是可以重复的
   API
     Set()/Set(arr) //arr是一维数组
     add(value)
     delete(value)
     clear();
     has(value)
     size
     
     Map()/Map(arr) //arr是二维数组
     set(key, value)
     delete(key)
     clear()
     has(key)
     size
    
5. for--of循环
   可以遍历任何容器
   数组
   对象
   伪/类对象
   字符串
   可迭代的对象
  
6. Promise
   解决`回调地狱`(回调函数的层层嵌套, 编码是不断向右扩展, 阅读性很差)
   能以同步编码的方式实现异步调用
   在es6之前原生的js中是没这种实现的, 一些第三方框架(jQuery)实现了promise
   ES6中定义实现API: 
    ```
    // 1. 创建promise对象
    var promise = new Promise(function(resolve, reject){ 
      // 做异步的操作 
      if(成功) { // 调用成功的回调
        resolve(result); 
      } else { // 调用失败的回调
        reject(errorMsg); 
      } 
    }) 
    // 2. 调用promise对象的then()
    promise.then(function(
      result => console.log(result), 
      errorMsg => alert(errorMsg)
    ))
    ```
7. class类
   用 class 定义一类
   用 constructor() 定义构造方法(相当于构造函数)
   一般方法: xxx () {}
   用extends来定义子类
   用super()来父类的构造方法
   方法重写: 将从父类中继承来的方法重新实现一遍
   js中没有方法重载(方法名相同, 但参数不同)的语法
  class Person () {
	constructor (name, age) {
		this.name = name;
		this.age = age;
	}
	setName (name) {
		this.name = name;
	}
	showInfo() {
		console.log(this.name, this. age);
	}
  }
  
  class Student expends Person ()  {
	constuctor (name, age, price) {
		super (name, age )
		this.price = price;
	}
	showInfo() {
		console.log(this.name, this. age, this.price);
	}
  }
  
  
8. 模块化(后面讲)

## ES7
 指数运算符: 
 Array.prototype.includes(value) : 判断数组中是否包含指定value
  
  
 区别方法的2种称谓
   静态(工具)方法
     Fun.xxx = function(){}
   实例方法
     所有实例对象 : Fun.prototype.xxx = function(){} //xxx针对Fun的所有实例对象
     某个实例对象 : fun.xxx = function(){} //xxx只是针对fun对象
				
				
				
				
				
				
				
				
				
				
				
				
				